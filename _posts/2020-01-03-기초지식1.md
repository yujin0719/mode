---
layout: post
title:  "기초지식"
date:   2020-01-03 20:40:00 +0900
categories: c++
--- 

# (1) 정수자료형

1. char : 1byte = 8bits -> 범위: 2^7-1
2. short : 2byte = 16bits -> 범위 : 2^15-1
3. int : 4byte = 32bits -> 범위 : 2^31-1
4. long long : 8byte = 64bits -> 범위 : 2^63-1

* integer overflow : 계산했을 때 지정한 자료형의 범위를 넘어가는 경우

```
  01111111  127
 +00000001  1
-----------------
  10000000  -128??????
```

* 실제로 코딩을 하다보면 이렇게 자료형의 범위를 넘어가는 경우가 발생하기 때문에 유의해야한다. 

# (2) 실수자료형

1. float : 4vyte = 32bits 
2. double : 8byte = 64bits
3. 실수에서 나타나는 소수점 표현도 이진법으로 나타낼수 있다.
```
ex) 3.75 = 2^1 + 2^0 + 2^-1 + 2^-2 => 11.11(2)


부동소수점 : sign(부호) + exponent(지수) + fraction(유효숫자)
- float 자료형: sign(1bit) + exp(8bit) + frac(23bit) 
- double 자료형: sign(1bit) + exp(11bit) + frac(52bit) 

- double이 더 많은 것을 표현할 수 있기 때문에 float보다 double 사용을 추천
```

### 실수연산에서 발생할 수 있는 오류

> 1. 실수 연산에서 발생하는 오차
>> - fraction field에는 1/3과 같은 무한 소수를 저장하려고 하면 앞의 일부만 저장된다.
>> - float은 10^-6까지, double은 10^-15까지 상대오차에서 안전
> 2. double에 long long 범위의 정수를 담을 수 없다.
>> - double의 유효숫자는 15자리이기 때문에 long long 범위의 정수를 모두 담을 수 없고, 오차를 발생시킬 수 있다.
> 3. 실수를 비교할 때는 등효를 사용할 수 없다. 
>> - 상대오차로인해 수학적으로는 값이 일치하지만 실제 변수에 저장된 값은 다를 수가 있다. 
>> - 0.1 + 0.1 + 0.1 과 0.3이 그 예이다.



저는 아래의 블로그를 참고해서 공부한 것이니 자세한 설명은 아래의 링크를 참고해주세요.

**https://blog.encrypted.gg/724?category=773649**

